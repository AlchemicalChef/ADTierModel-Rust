\* ADTierModel.cfg - TLC Model Checker Configuration
\* Version 2.0 - Updated for nested groups, primary groups, and service accounts
\*
\* Run with: tlc ADTierModel.tla -config ADTierModel.cfg
\* Or with TLA+ Toolbox: Import this as a model configuration

\* =============================================================================
\* SPECIFICATION
\* =============================================================================

SPECIFICATION Spec

\* =============================================================================
\* SAFETY INVARIANTS TO VERIFY
\* =============================================================================

\* Type checking
INVARIANT TypeInvariant

\* Core tier model safety properties
INVARIANT TierIsolation
INVARIANT Tier0InfrastructurePlacement
INVARIANT GpoRestrictionsValid
INVARIANT ObjectTierConsistency

\* New invariants for nested groups and service accounts
INVARIANT NoCircularGroupNesting
INVARIANT PrimaryGroupConsistency
INVARIANT ServiceAccountHardening

\* Session and credential safety
INVARIANT NoCrossTierSessions
INVARIANT Tier0CredentialsProtected
INVARIANT Tier1CredentialsProtected

\* Combined invariants
INVARIANT AdminSafetyInvariant
INVARIANT SessionSafetyInvariant
INVARIANT SafetyInvariant

\* =============================================================================
\* CONSTANTS - Small model for tractable verification
\* =============================================================================

\* Define the objects in the model
\* Keep sets small to avoid state space explosion
\* This represents a minimal test scenario with:
\* - 3 users (u1, u2 regular users, sa1 service account)
\* - 2 computers (c1, c2)
\* - 6 groups (2 admin groups per tier)

CONSTANTS
    \* Use string names that match the TierOfGroup function in the spec
    Objects = {u1, u2, c1, c2, sa1,
               "Tier0-Admins", "Tier0-Operators",
               "Tier1-Admins", "Tier1-Operators",
               "Tier2-Admins", "Tier2-Operators"}
    Users = {u1, u2, sa1}
    Computers = {c1, c2}
    Groups = {"Tier0-Admins", "Tier0-Operators",
              "Tier1-Admins", "Tier1-Operators",
              "Tier2-Admins", "Tier2-Operators"}
    ServiceAccounts = {sa1}

\* The group names match those in the TierOfGroup function:
\* - "Tier0-Admins", "Tier0-Operators" -> Tier0
\* - "Tier1-Admins", "Tier1-Operators" -> Tier1
\* - "Tier2-Admins", "Tier2-Operators" -> Tier2
\*
\* Note: The Init state sets primaryGroup to "Domain Users" which is a well-known
\* group not in Groups. This is handled correctly by the spec - TransitiveGroupClosure
\* only processes groups that are in the Groups constant.

\* =============================================================================
\* STATE CONSTRAINTS (to limit state space)
\* =============================================================================

\* These constraints limit the state space to make model checking tractable
\* while still exploring meaningful scenarios

CONSTRAINT
    /\ \A g \in Groups: Cardinality(nestedGroupMembership[g]) <= 2
    /\ Cardinality(activeSessions) <= 3
    /\ \A comp \in Computers: Cardinality(credentialCache[comp]) <= 2
    /\ \A obj \in Objects: Cardinality(groupMembership[obj]) <= 3

\* =============================================================================
\* LIVENESS PROPERTIES (requires fairness)
\* =============================================================================

\* Uncomment to check liveness properties (requires FairSpec)
\* PROPERTY EventuallyAllServiceAccountsHardened
\* PROPERTY EventuallyNoStaleAccounts
\* PROPERTY EventuallyFullCompliance

\* =============================================================================
\* SYMMETRY OPTIMIZATION
\* =============================================================================

\* Symmetry can significantly reduce state space by treating
\* permutations of symmetric elements as equivalent states.
\* Define symmetry sets if using symmetric model values.

\* SYMMETRY symmetry_Users
\* SYMMETRY symmetry_Computers
